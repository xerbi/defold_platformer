SPEED_WALK = 100
JUMP_SPEED = 200
GRAVITY = 500
FALL_SPEED = -100
LEFT_WALL = -1
RIGHT_WALL = 1

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("#camera", "acquire_camera_focus")
	msg.post("@render:", "use_camera_projection")
	self.velocity = vmath.vector3()
	self.direction = 0
	self.animation = nil
	self.is_ground = false
	self.right_wall = false
	self.left_wall = false
	self.correction = vmath.vector3()

	self.jump = false
	--был ли соверше двойной прыжок
	self.is_double_jump = false
	--размеры спрайта
	self.size_spite = go.get("go#sprite", "size")
	--длина луча для определения припятствия
	self.ray_length = self.size_spite.x / 2
	--текущая нажатая клавиша
	self.action_id = nil
	--расположение персонажа в пространстве
	self.up_ray_dote = false

end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

local function draw_line(from, to)
	msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = vmath.vector4(1,0,0,1) })
end
--создание трех векторов по условиям:
--current_position - вектор, который будет меняться,
--static_pos -- вектор постоянной длинны,
--vector_steps -- вектор изменения.
local function create_rays_points(current_position, static_pos, vector_steps)
	local number_points = 3
	local save_object = {}
	local change_in_x = vector_steps.x
	local change_in_y = vector_steps.y
	for i = 1, number_points do
		table.insert(save_object, vmath.vector3(
		current_position.x + static_pos.x + change_in_x,
		current_position.y + static_pos.y + change_in_y,
		current_position.z))
		change_in_x = change_in_x - vector_steps.x
		change_in_y = change_in_y - vector_steps.y
	end
	return save_object
end

local function check_moving_x(self, current_position)
	local start_points = create_rays_points(current_position,
		vmath.vector3(0, 0, 0), vmath.vector3(0, self.ray_length - 2, 0))
	local end_left_points = create_rays_points(current_position,
		vmath.vector3(- self.ray_length + 5, 0, 0), vmath.vector3(0, self.ray_length - 2, 0))
	local end_right_points = create_rays_points(current_position,
		vmath.vector3(self.ray_length - 5, 0, 0), vmath.vector3(0, self.ray_length - 2, 0))
	local my_groups = { hash("ground") }
	self.left_wall = false
	self.right_wall = false
	for i = 1, 3 do
		if (physics.raycast(start_points[i], end_left_points[i], my_groups)) then
			self.left_wall = true
			break
		end
		if (physics.raycast(start_points[i], end_right_points[i], my_groups)) then
			self.right_wall = true
			break
		end
	end
end

local function check_moving_y(self, current_position)
	local start_points_down = create_rays_points(current_position,
		vmath.vector3(0, 0, 0), vmath.vector3(self.ray_length - 8, 0, 0))
	local end_points_down = create_rays_points(current_position,
		vmath.vector3(0, - (self.ray_length), 0), vmath.vector3(self.ray_length - 8, 0, 0))
	local my_groups = { hash("ground") }
	local hit = nil
	for i = 1, 3 do
		hit = physics.raycast(start_points_down[i], end_points_down[i], my_groups)
		if (hit) then break end
	end
	for i = 1, 3 do
		draw_line(start_points_down[i], end_points_down[i])
	end
	if (hit) then
		self.velocity.y = 0
		self.is_ground = true
		--компенсация
		-- if (current_position.y > hit.position.y) then
		-- 	pprint(hit)
		-- 	go.set_position(vmath.vector3(current_position.x, hit.position.y, 0))
		-- end
		pprint(current_position)
		pprint(hit)
	else
		self.is_ground = false
	end
end

function update(self, dt)
	--текущее положение объекта
	local current_position = go.get_position()
	check_moving_x(self, current_position)
	if (self.jump) then self.jump = false
	else check_moving_y(self, current_position) end
	--применение гравитации
	self.velocity.y = self.velocity.y - GRAVITY * dt
	if (self.is_ground
	or (self.right_wall and self.action_id == hash('right'))
	or (self.left_wall and self.action_id == hash('left'))) then
		self.velocity.y = 0
		--сбрасываем двойно прыжок
		self.is_double_jump = false
		self.jump = false
	end
	if (self.direction ~= 0) then
		--направление спрайта (flip)
		if (self.direction > 0 or self.right_wall) then
			sprite.set_hflip("#sprite", false)
		else
			sprite.set_hflip("#sprite", true)
		end
	end
	--включение анимации
	if (self.direction > 0 and self.is_ground) then
		if (self.animation ~= hash('walk')) then
			sprite.play_flipbook("#sprite", hash("walk"))
		end
		self.animation = hash('walk')
	elseif (self.direction < 0 and self.is_ground) then
		if (self.animation ~= hash('walk')) then
			sprite.play_flipbook("#sprite", hash("walk"))
		end
		self.animation = hash('walk')
	elseif (self.velocity.y < 0) then
		sprite.play_flipbook("#sprite", hash("fall"))
		self.animation = hash('fall')
	elseif (self.velocity.y > 0) then
		sprite.play_flipbook("#sprite", hash("jump"))
		self.animation = hash('jump')
	elseif ((self.right_wall or self.left_wall) and self.is_ground ~= true) then
		sprite.play_flipbook("#sprite", hash("wall_jump"))
		self.animation = hash('wall_jump')
	elseif (self.action_id == hash('double_jump')) then
		sprite.play_flipbook("#sprite", hash("double_jump"))
		self.animation = hash('double_jump')
	else
		if (self.animation ~= hash('idle')) then
			sprite.play_flipbook("#sprite", hash("idle"))
		end
		self.animation = hash('idle')
	end	
	--установка новой позиции
	go.set_position(current_position + self.velocity * dt)
	self.velocity.x = 0
	self.direction = 0
	-- self.is_ground = false
	self.action_id = nil
end

function on_message(self, message_id, message, sender)
	if message_id == hash("contact_point_response") then
		if message.distance > 0 then
			local proj = vmath.project(self.correction, message.normal * message.distance)
			if proj < 1 then
				local comp = (message.distance - message.distance * proj) * message.normal
				go.set_position(go.get_position() + comp)
				self.correction = self.correction + comp
			end
		end
	end
end

local function walk(self)
	self.velocity.x = SPEED_WALK * self.direction
end

local function jump(self)
	pprint('this is jump')
	self.velocity.y = JUMP_SPEED
	self.is_ground = false
	self.jump = true
end

function on_input(self, action_id, action)
	if (action_id == hash('right')) then
		if (self.right_wall ~= true) then self.direction = 1 end
		self.action_id = hash('right')
	end
	if (action_id == hash('left')) then
		if (self.left_wall ~= true) then self.direction = -1 end
		self.action_id = hash('left')
	end
	walk(self)
	if (self.is_ground) then
		if (action_id == hash('jump') and action.pressed) then
			jump(self)
			self.action_id = hash('jump')
		end
	elseif (self.is_double_jump ~= true) then
		-- self.is_double_jump = true
		-- jump(self)
		-- self.action_id = hash('double_jump')
	end
end